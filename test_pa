import tkinter as tk
from tkinter import simpledialog, messagebox
import subprocess
import requests
import urllib.error
from urllib.request import urlopen
from bs4 import BeautifulSoup
import re
from fpdf import FPDF
import nmap




def get_wordpress_scan_data(site_url):
    """
    This function gets the WordPress scan data.

    Parameters:
    site_url (str): The URL of the WordPress site.

    Returns:
    dict: The WordPress scan data.
    """
    try:
        # Exécute WPScan avec l'URL du site WordPress fournie en argument
        result = subprocess.run(["wpscan", "--url", site_url, "--enumerate", "u", "--ignore-main-redirect", "--wp-content-dir", "/path/to/wp-content"], capture_output=True, text=True)
        return {"WPScan Output": result.stdout}
    except FileNotFoundError:
        return {"Error": "WPScan not found on the system. Make sure it is installed and accessible in your PATH."}

def create_pdf_report(data, filename):
    """
    This function creates a PDF report from the provided data.

    Parameters:
    data (dict): The data to be included in the report.
    filename (str): The filename for the PDF report.
    """
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt="WordPress Scan Report", ln=True, align="C")
    pdf.ln(10)
    for key, value in data.items():
        pdf.cell(200, 10, txt=f"{key}: {value}", ln=True)
    pdf.output(filename)

class MenuGUI:
    
    def __init__(self, root, serverip):
        self.root = root
        self.serverip = serverip
        self.root.title("Menu")
        self.root.geometry("400x400")

        self.menu_label = tk.Label(self.root, text="Select from the menu:")
        self.menu_label.pack()

        self.menu_options = tk.Listbox(self.root)
        options = [
            "XSS Tracer",
            "Wordpress",
            "SQL-injection",
            "Sites",
            "Nmap",
            "Check CVE",
            "Generate Report",
            "Exit"
        ]
        for option in options:
            self.menu_options.insert(tk.END, option)
        self.menu_options.pack()
        self.report_data = {}

        self.entry = tk.Entry(self.root)
        self.entry.pack()

        self.select_button = tk.Button(self.root, text="Select", command=self.handle_selection)
        self.select_button.pack()

        self.text = tk.Text(self.root, height=10, width=50)
        self.text.pack()

    def handle_selection(self):
        selected_option = self.menu_options.get(self.menu_options.curselection())
        if selected_option == "XSS Tracer":
            self.report_data["XSS Tracer"] = self.perform_xss_attack()
        elif selected_option == "Wordpress":
            self.report_data["Wordpress"] = self.wpscan_scan()
        elif selected_option == "SQL-injection":
            self.report_data["SQL-injection"] = self.sqlmap_attack()
        elif selected_option == "Sites":
            self.report_data["Sites"] = self.getSites()
        elif selected_option == "Check CVE":
            self.report_data["Check CVE"] = self.search_cve()
        elif selected_option == "Nmap":
            self.report_data["Nmap"] = self.nmap_scan()
        elif selected_option == "Generate Report":
            self.generate_report("Scan")
        elif selected_option == "Exit":
            self.root.quit()

    def generate_report(self, category):
        report_filename = f"{category}_report.pdf"
        with open(report_filename, "w") as report_file:
            report_file.write(f"Creating PDF report: {report_filename}")
        messagebox.showinfo("Report Generated", f"PDF report for {category} has been generated: {report_filename}")

        # Generate PDF report
        try:
            create_pdf_report(self.report_data, report_filename)
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while generating PDF report: {str(e)}")

    def nmap_scan(self):
        target = simpledialog.askstring("Nmap", "Enter the target IP or hostname:")
        if target:
            nm = nmap.PortScanner()
            nm.scan(hosts=target, arguments='-sV -p 1-1024')  
            scan_result = nm

            output_window = tk.Toplevel(self.root)
            output_window.title("Nmap Scan Output")
            output_text = tk.Text(output_window)

            for host in scan_result.all_hosts():
                output_text.insert(tk.END, f"Host: {host}\n")
                for proto in scan_result[host].all_protocols():
                    output_text.insert(tk.END, f"Protocol: {proto}\n")
                    ports = scan_result[host][proto].keys()
                    for port in ports:
                        state = scan_result[host][proto][port]['state']
                        service = scan_result[host][proto][port]['name']
                        output_text.insert(tk.END, f"Port: {port} - State: {state} - Service: {service}\n")

            output_text.pack(fill=tk.BOTH, expand=True)
            output_window.mainloop()  
    
    def search_cve(self):
        cve_id = simpledialog.askstring("CVE", "Entrez l'ID de la CVE:")
        if cve_id:
            url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
            try:
                response = requests.get(url)
                soup = BeautifulSoup(response.text, 'html.parser')
                cve_detail_element = soup.find('p', attrs={'data-testid': 'vuln-description'})
                if cve_detail_element is not None:
                    cve_detail = cve_detail_element.text.strip()
                    self.text.insert(tk.END, f"CVE Detail for {cve_id}:\n")
                    self.text.insert(tk.END, f"{cve_detail}\n")
                else:
                    self.text.insert(tk.END, f"No detail found for CVE: {cve_id}\n")
            except Exception as e:
                self.text.insert(tk.END, f"An error occurred while checking CVE: {str(e)}\n")
    
    def perform_xss_attack(self):
        url = simpledialog.askstring("XSS Tracer", "Enter the URL to perform XSS attack on:")
        if url:
            # Define the XSS payload
            payload = "<script>alert('XSS Attack!')</script>"

            # Create the form data with the XSS payload
            form_data = {
                "input_field": payload
            }

            print(f"Sending POST request to: {url}")
            print(f"Data: {form_data}")

            try:
                # Send the POST request with the form data
                response = requests.post(url, data=form_data)

                # Print the response headers
                print(f"Response Headers: {response.headers}")

                # Check if the request was successful
                if response.status_code == 200:
                    print("XSS Attack successful!")
                else:
                    print("XSS Attack failed. Status code:", response.status_code)
            except requests.exceptions.RequestException as e:
                print("An error occurred:", e)

    def wpscan_scan(self):
        site_url = simpledialog.askstring("Wordpress", "Enter the Wordpress site URL:")
        if site_url:
            try:
            # Exécute WPScan avec l'URL du site WordPress fournie en argument
                result = subprocess.run(["wpscan", "--url", site_url, "--enumerate", "u", "--ignore-main-redirect", "--wp-content-dir", "/path/to/wp-content"], capture_output=True, text=True)
                output_window = tk.Toplevel(self.root)
                output_window.title("WPScan Output")
                output_text = tk.Text(output_window)
                output_text.insert(tk.END, result.stdout)
                output_text.pack(fill=tk.BOTH, expand=True)
            except FileNotFoundError:
                print("WPScan n'a pas été trouvé sur votre système. Assurez-vous qu'il est installé et accessible dans votre chemin d'exécution.")

    def sqlmap_attack(self):
        url = simpledialog.askstring("SQLMap", "Enter the URL to perform SQLMap attack on:")
        if url:
            try:
                # Exécuter SQLMap avec l'URL fournie en argument
                result = subprocess.run(["sqlmap", "-u", url, "--dbs"], capture_output=True, text=True)
                messagebox.showinfo("SQLMap Output", result.stdout)
            except FileNotFoundError:
                print("SQLMap n'a pas été trouvé sur votre système. Assurez-vous qu'il est installé et accessible dans votre chemin d'exécution.")

    def getSites(self):
        """
        get all websites on same server
        from bing search
        """
        lista = []
        page = 1
        while page <= 101:
            try:
                bing = "http://www.bing.com/search?q=ip%3A" + self.serverip + "+&count=50&first=" + str(page)
                openbing = urlopen(bing)
                soup = BeautifulSoup(openbing, 'html.parser')
                findwebs = [h2.a['href'] for h2 in soup.find_all('h2')]
                for i in range(len(findwebs)):
                    allnoclean = findwebs[i]
                    findall1 = re.findall('http://(.*?)/', allnoclean)
                    for idx, item in enumerate(findall1):
                        if 'www' not in item:
                            findall1[idx] = 'http://www.' + item + '/'
                        else:
                            findall1[idx] = 'http://' + item + '/'
                    lista.extend(findall1)
                
                page += 50
            except urllib.error.URLError:
                pass
        self.sites = list(set(lista))  # use set to get unique items
        print('\033c')  # clear screen
        print('[*] Found', len(lista), 'Website\n')
        for site in self.sites :
            print(site)    

root = tk.Tk()
menu_gui = MenuGUI(root,"217.70.184.55")
root.mainloop()
