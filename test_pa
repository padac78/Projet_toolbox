import tkinter as tk
import tkinter.ttk as ttk
import threading
from tkinter import simpledialog, messagebox
import subprocess
import requests
import urllib.error
from urllib.request import urlopen
from bs4 import BeautifulSoup
import re
from fpdf import FPDF
import nmap



def create_pdf_report(data, filename, title):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=title, ln=True, align="C")  # Use the title parameter here
    pdf.ln(10)
    for key, value in data.items():
        if not isinstance(value, str):
            value = str(value)
        pdf.cell(200, 10, txt=f"{key}: {value}", ln=True)
    pdf.output(filename)

class MenuGUI:
    
    def __init__(self, root, serverip):
        self.root = root
        self.serverip = serverip
        self.root.title("Menu")
        self.root.geometry("400x400")

        self.menu_label = tk.Label(self.root, text="Sélectionnez une option : ")
        self.menu_label.pack()

        self.menu_options = tk.Listbox(self.root)
        options = [
            "XSS Tracer",
            "Wordpress",
            "SQL-injection",
            "Sites",
            "Nmap",
            "Check CVE",
            "Generate Report",
            "Exit"
        ]
        for option in options:
            self.menu_options.insert(tk.END, option)
        self.menu_options.pack()
        self.report_data = {}

        self.entry = tk.Entry(self.root)
        self.entry.pack()

        self.select_button = tk.Button(self.root, text="Select", command=self.handle_selection)
        self.select_button.pack()

        self.text = tk.Text(self.root, height=10, width=50)
        self.text.pack()

    def handle_selection(self):
        selected_option = self.menu_options.get(self.menu_options.curselection())
        if selected_option == "XSS Tracer":
            self.report_data["XSS Tracer"] = self.perform_xss_attack()
        elif selected_option == "Wordpress":
            self.report_data["Wordpress"] = self.wpscan_scan()
        elif selected_option == "SQL-injection":
            self.report_data["SQL-injection"] = self.sqlmap_attack()
        elif selected_option == "Sites":
            self.report_data["Sites"] = self.getSites()
        elif selected_option == "Check CVE":
            self.report_data["Check CVE"] = self.search_cve()
        elif selected_option == "Nmap":
            self.report_data["Nmap"] = self.nmap_scan()
        elif selected_option == "Generate Report":
            self.generate_report("Scan")
        elif selected_option == "Exit":
            self.root.quit()
     

    def generate_report(self, category):
        report_filename = f"{category}_report.pdf"
        with open(report_filename, "w") as report_file:
            report_file.write(f"Creating PDF report: {report_filename}")
        messagebox.showinfo("Report Generated", f"PDF report for {category} has been generated: {report_filename}")

        # Generate PDF report
        try:
            create_pdf_report(self.report_data, report_filename, category)  # Pass the category as the title
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred while generating PDF report: {str(e)}")
    def nmap_scan(self):
        target = simpledialog.askstring("Nmap", "Enter the target IP or hostname:")
        if target:
            output_window = tk.Toplevel(self.root)
            output_window.title("Nmap Scan Output")
            output_text = tk.Text(output_window)
            output_text.pack(fill=tk.BOTH, expand=True)

            progress = ttk.Progressbar(output_window, length=200, mode='indeterminate')
            progress.pack()

            def scan():
                nm = nmap.PortScanner()
                nm.scan(hosts=target, arguments='-p 1-1024')
                scan_result = nm

                for host in scan_result.all_hosts():
                    output_text.insert(tk.END, f"Host: {host}\n")
                    for proto in scan_result[host].all_protocols():
                        output_text.insert(tk.END, f"Protocol: {proto}\n")
                        ports = scan_result[host][proto].keys()
                        for port in ports:
                            state = scan_result[host][proto][port]['state']
                            service = scan_result[host][proto][port]['name']
                            output_text.insert(tk.END, f"Port: {port} - State: {state} - Service: {service}\n")

                progress.stop()

            threading.Thread(target=scan).start()
            progress.start(10)  
    
    def search_cve(self):
        cve_id = simpledialog.askstring("CVE", "Entrez l'ID de la CVE:")
        if cve_id:
            url = f"https://nvd.nist.gov/vuln/detail/{cve_id}"
            try:
                response = requests.get(url)
                soup = BeautifulSoup(response.text, 'html.parser')
                cve_detail_element = soup.find('p', attrs={'data-testid': 'vuln-description'})
                if cve_detail_element is not None:
                    cve_detail = cve_detail_element.text.strip()
                    self.text.insert(tk.END, f"CVE Detail for {cve_id}:\n")
                    self.text.insert(tk.END, f"{cve_detail}\n")
                else:
                    self.text.insert(tk.END, f"No detail found for CVE: {cve_id}\n")
            except Exception as e:
                self.text.insert(tk.END, f"An error occurred while checking CVE: {str(e)}\n")
    
    def perform_xss_attack(self):
        url = simpledialog.askstring("XSS Tracer", "Enter the URL to perform XSS attack on:")
        if url:
            # Define the XSS payload
            payload = "<script>alert('XSS Attack!')</script>"

            # Create the form data with the XSS payload
            form_data = {
                "input_field": payload
            }

            print(f"Sending POST request to: {url}")
            print(f"Data: {form_data}")

            try:
                # Send the POST request with the form data
                response = requests.post(url, data=form_data)

                # Print the response headers
                print(f"Response Headers: {response.headers}")

                # Check if the request was successful
                if response.status_code == 200:
                    print("XSS Attack successful!")
                else:
                    print("XSS Attack failed. Status code:", response.status_code)
            except requests.exceptions.RequestException as e:
                print("An error occurred:", e)

    def wpscan_scan(self):
        site_url = simpledialog.askstring("Wordpress", "Entre l'URL du site à scanner:")
        if site_url:
            try:
                # Exécute WPScan avec l'URL du site WordPress fournie en argument
                result = subprocess.run(["wpscan", "--url", site_url, "--enumerate", "u", "--ignore-main-redirect"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, check=True)
                output_window = tk.Toplevel(self.root)
                output_window.title("WPScan Output")
                output_text = tk.Text(output_window)
                output_text.insert(tk.END, result.stdout)
                output_text.pack(fill=tk.BOTH, expand=True)
                return result.stdout  # Return the output as a string
                console.log(type(result))
            except (FileNotFoundError, subprocess.CalledProcessError) as e:
                error_message = str(e)
                print(error_message)
                return error_message  # Return the error message as a string
                
    def sqlmap_attack(self):
        url = simpledialog.askstring("SQLMap", "Enter the URL to perform SQLMap attack on:")
        if url:
            try:
                # Exécuter SQLMap avec l'URL fournie en argument
                result = subprocess.run(["sqlmap", "-u", url, "--dbs"], capture_output=True, text=True)
                messagebox.showinfo("SQLMap Output", result.stdout)
            except FileNotFoundError:
                print("SQLMap n'a pas été trouvé sur le système. Assurez-vous qu'il est installé et accessible dans votre chemin d'exécution.")

    def getSites(self):
        """
        get all websites on same server
        from bing search
        """
        lista = []
        page = 1
        while page <= 101:
            try:
                bing = "http://www.bing.com/search?q=ip%3A" + self.serverip + "+&count=50&first=" + str(page)
                openbing = urlopen(bing)
                soup = BeautifulSoup(openbing, 'html.parser')
                findwebs = [h2.a['href'] for h2 in soup.find_all('h2')]
                for i in range(len(findwebs)):
                    allnoclean = findwebs[i]
                    findall1 = re.findall('http://(.*?)/', allnoclean)
                    for idx, item in enumerate(findall1):
                        if 'www' not in item:
                            findall1[idx] = 'http://www.' + item + '/'
                        else:
                            findall1[idx] = 'http://' + item + '/'
                    lista.extend(findall1)
                
                page += 50
            except urllib.error.URLError:
                pass
        self.sites = list(set(lista))  # use set to get unique items
        print('\033c')  # clear screen
        print('[*] Found', len(lista), 'Website\n')
        for site in self.sites :
            print(site)    

root = tk.Tk()
menu_gui = MenuGUI(root,"localhost")
root.mainloop()
